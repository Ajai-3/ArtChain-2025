import { injectable } from "inversify";
import { GoogleGenAI } from "@google/genai";
import axios from "axios";

interface AIGenerationParams {
  prompt: string;
  negativePrompt?: string;
  resolution: string;
  seed?: number;
  model?: string;
}

interface AIGenerationResult {
  images: string[];
  generationTime?: number;
}

interface IAIProvider {
  generateImage(params: AIGenerationParams): Promise<AIGenerationResult>;
  testConnection(): Promise<boolean>;
}

// Pollinations.ai Provider (Free, no API key needed)
@injectable()
class PollinationsProvider implements IAIProvider {
  async generateImage(params: AIGenerationParams): Promise<AIGenerationResult> {
    const { prompt, seed, model, resolution } = params;
    const images: string[] = [];
    
    const modelName = model || 'flux';
    const seedValue = seed || Math.floor(Math.random() * 1000000);
    const [width, height] = resolution.split('x').map(Number);
    const encodedPrompt = encodeURIComponent(prompt);

    // Construct URL
    const url = `https://image.pollinations.ai/prompt/${encodedPrompt}?model=${modelName}&width=${width}&height=${height}&seed=${seedValue}&nologo=true`;
    
    console.log(`[Pollinations] Generating: ${url}`);

    try {
      // Try to download the image to save as base64
      const response = await axios.get(url, {
        responseType: 'arraybuffer'
      });

      const base64Image = Buffer.from(response.data, 'binary').toString('base64');
      const dataUri = `data:image/jpeg;base64,${base64Image}`;
      
      images.push(dataUri);
      console.log(`[Pollinations] Image downloaded successfully`);
    } catch (error) {
      console.warn(`[Pollinations] Download failed, falling back to URL:`, error instanceof Error ? error.message : error);
      // Fallback: Save the URL if download fails
      images.push(url);
    }

    return {
      images,
      generationTime: 0
    };
  }

  async testConnection(): Promise<boolean> {
    try {
      await axios.get('https://image.pollinations.ai/prompt/test?width=64&height=64');
      return true;
    } catch (error) {
      return false;
    }
  }
}

// Puter.js Provider (requires API key)
class PuterProvider implements IAIProvider {
  constructor(private apiKey?: string) {}

  async generateImage(params: AIGenerationParams): Promise<AIGenerationResult> {
    // TODO: Implement Puter.js API integration
    throw new Error('Puter.js provider not yet implemented. Please configure API key and implementation.');
  }

  async testConnection(): Promise<boolean> {
    return false;
  }
}

// Gemini Provider (requires API key)
class GeminiProvider implements IAIProvider {
  private client: GoogleGenAI | null = null;

  constructor(private apiKey?: string) {
    if (apiKey) {
      this.client = new GoogleGenAI({ apiKey });
    }
  }

  async generateImage(params: AIGenerationParams): Promise<AIGenerationResult> {
    if (!this.client) {
      throw new Error("Gemini API key not configured");
    }

    const { prompt } = params;
    const images: string[] = [];

    try {
      const response = await this.client.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
      });

      if (response.candidates && response.candidates.length > 0) {
        for (const part of response.candidates[0].content.parts) {
           if (part.inlineData) {
            const imageData = part.inlineData.data;
            const mimeType = "image/png"; 
            const dataUri = `data:${mimeType};base64,${imageData}`;
            images.push(dataUri);
          }
        }
      }

      if (images.length === 0) {
        throw new Error("No image generated by Gemini");
      }

      return {
        images,
        generationTime: 0 
      };
    } catch (error) {
      console.error("Gemini generation error:", error);
      throw error;
    }
  }

  async testConnection(): Promise<boolean> {
    if (!this.client) return false;
    try {
      await this.client.models.generateContent({
        model: "gemini-2.5-flash",
        contents: "Test",
      });
      return true;
    } catch {
      return false;
    }
  }
}

@injectable()
export class AIProviderService {
  private providers: Map<string, IAIProvider> = new Map();

  constructor() {
    // Initialize providers
    this.providers.set('pollinations', new PollinationsProvider());
    this.providers.set('puter', new PuterProvider());
    
    // Initialize Gemini with env var if available
    const geminiKey = process.env.GEMINI_API_KEY;
    this.providers.set('gemini', new GeminiProvider(geminiKey));
  }

  async generateImage(provider: string, params: AIGenerationParams): Promise<AIGenerationResult> {
    const providerInstance = this.providers.get(provider);
    
    if (!providerInstance) {
      throw new Error(`Provider '${provider}' not found`);
    }

    return await providerInstance.generateImage(params);
  }

  async testProvider(provider: string): Promise<boolean> {
    const providerInstance = this.providers.get(provider);
    
    if (!providerInstance) {
      throw new Error(`Provider '${provider}' not found`);
    }

    return await providerInstance.testConnection();
  }

  setApiKey(provider: string, apiKey: string) {
    // Update provider with API key
    if (provider === 'puter') {
      this.providers.set('puter', new PuterProvider(apiKey));
    } else if (provider === 'gemini') {
      this.providers.set('gemini', new GeminiProvider(apiKey));
    }
  }
}
